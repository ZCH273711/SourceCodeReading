# Redis7.2源码阅读笔记——ziplist

压缩列表（ziplist）是redis中zset的两种底层实现之一，另一种是skiplist，在另一篇笔记中已经对skiplist主要部分分析了。这篇笔记用来记录阅读redis中的ziplist实现源码的笔记。

## ziplist简介

ziplist的实现主要在ziplist.h和ziplist.c文件中。在ziplist.c的源码的官方注释中可以了解到，ziplist是一种被设计来提高内存使用率的数据结构，他可以存储字符串和整数类型，在ziplist头尾压入和弹出元素的时间复杂度为O(1)，但是考虑到在中间位置插入和删除会涉及内存的重新分配和复制，所以整体的时间复杂度收到ziplist占用空间的影响。

压缩列表展开的形式如下：

<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>

注意：压缩列表的四个特殊字段都按照little endian编码，即低位编址（操作系统中有讲）。

- 其中zlbytes是一个32位无符号类型整数，用来记录整个压缩列表占用的字节数（包括zlbytes自己的4字节）。设置该成员是为了改变压缩列表大小时不用去遍历整个列表。
- zltail元素也是一个32位无符号整数类型，用来记录列表中最后一个元素的字节偏移
- zllen元素是一个16位无符号整数类型，用来记录整个列表的元素个数，如果元素个数大于2^16 - 2，则设置为2^16 - 1，并且需要遍历整个列表才能知道有多少个元素。
- zlend是一个标记字节，恒为0xFF，标志整个压缩列表的结束。

## ziplist中的entry

压缩列表中的每一个entry元素展开如下：

<prevlen> <encoding> <entry-data>

- 其中prevlen表示前一个元素所占字节数，方便反向遍历。该字段的编码规则如下：
  - 如果前一个数据元素总长度小于254，则只需要一个字节。（为什么不是255呢，因为压缩列表中的zlend就是255，标志列表的结束，所以不能为255）
  - 否则当前一个元素的总长度大于等于254，则需要5个字节，其中第一个字节恒为0xFE(254)，实际表示前一个元素长度为后四个字节。
- encoding表示当前元素的类型，有字符串和整数两种，同时encoding也会含有字符串的长度信息。可以根据encoding的第一字节的高二位分别不同长度的字符串和整数，具体的编码规则如下：
  - |00pppppp| 长度不大于63的字符串，encoding为一字节，后六位记录字符串的长度。
  - |01pppppp|qqqqqqqq| 2字节，字节长度不大于16383的字符串，后14位记录具体长度。注意：后14位长度采用大端地址（Big Endian）。
  - |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| 5字节，长度大于等于16384的字符串，第一字节的后六位没有使用，使用后面四个字节记录具体长度，同样采用大端地址。
  - |11000000| 3字节，16位有符号整数，其中一字节encoding，接着后面两字节<entry-data>的整数。
  - |11010000| 5字节，32位有符号整数，同样后面接4字节整数。
  - |11100000| 9字节，64位有符号整数，后面接8个字节。
  - |11110000| 4字节，24位有符号整数。
  - |11111110| 2字节，后面接8位有符号整数。
  - |1111xxxx| 12个立即数，也就是说后面四位直接表示数字，从0001到1101（0000，1110，1111不可用），一共12个数，从0开始。
  - 注意：和特殊字段一样，整数采用小端地址存储。
- entry-data即存储的数据，如果存储的数据为小整数类型，则这部分会省略，直接并入encoding字段。